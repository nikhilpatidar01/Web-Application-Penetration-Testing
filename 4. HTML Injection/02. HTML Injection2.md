
# 🔴 HTML Injection — Blacklist (GET & POST)

---

## 🚫 1. Blacklist-Based Filtering (GET Method)

```php
html-injection-black-list-get.php
```

```php
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HTML Injection Blacklist - GET</title>
</head>
<body>
    <h1>HTML Injection Blacklist - GET</h1>
    <?php
    if (isset($_REQUEST['user'])) {
        $user_name = preg_replace("/<|>/", "", $_REQUEST['user']); // Removes < and >
        echo "<h2>" . $user_name . "!!</h2>";
    }
    ?>
</body>
</html>
```

### 💥 Exploit:

```url
http://example.com/html-injection-black-list-get.php?user=<h1>XSS</h1>
```

### 🛠️ Bypass Technique:

> Use encoded payload:

```
<script>alert('XSS')</script>  
→ Encoded as: %3Cscript%3Ealert('XSS')%3C/script%3E
```

> ⚠️ **Weak blacklist** — only removes `<` and `>`, but many other dangerous inputs like quotes, event handlers, or `img` tags can still execute malicious code.

---

## 🚫 2. Blacklist-Based Filtering (POST Method)

```php
html-injection-black-list-post.php
```

```php
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HTML Injection Blacklist - POST</title>
</head>
<body>
    <h1>HTML Injection Blacklist - POST</h1>
    <form action="html-injection-black-list-post.php" method="POST">
        User Name: <input type="text" name="user"><br>
        <input type="submit" value="Login">
    </form>

    <?php
    if (isset($_REQUEST['user'])) {
        $user_name = preg_replace("/<|>/", "", $_REQUEST['user']);
        echo "<h2>" . $user_name . "!!</h2>";
    }
    ?>
</body>
</html>
```

### 💥 Exploit:

```php
<h1>Hello!</h1>
```

```php
<img src=x onerror=alert('XSS')>
```

### 🛠️ Bypass Technique:

> Use HTML entities:

```php
&lt;img src=x onerror=alert(1)&gt;
```

> ⚠️ **Encoding evasion** — Blacklists are easy to bypass using encoded characters or alternative syntax.

---

# 🔴 HTML Injection — Whitelist

 ## ⚠️ 1. **html-injection-white-list.php — Still Vulnerable**

**Below is your provided code, updated only for layout consistency and readability. The HTML injection vulnerability remains because the regex does not fully validate input (it only checks if at least one allowed character is present anywhere in the input), so injection is still possible.**

```php
html-injection-white-list.php
```

```php
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>HTML Injection Whitelist</title>
</head>
<body>
    <h1>HTML Injection Whitelist</h1>
    <form action="html-injection-white-list.php" method="POST">
        User Name: <input type="text" name="user"><br />
        <input type="submit" value="Login">
    </form>

    <?php
    if (isset($_REQUEST['user'])) {
        $user_name = $_REQUEST['user'];

       // This Regex only checks for the presence of at least one allowed character.
       // Inputs with both allowed and unallowed characters will still pass through.
        if (!preg_match('/[a-z\d_\-\.]/i', $user_name)) {
            die("Don't try to Inject Code");
        } else {
          // No Sanitization or escaping still vulnerable to HTML Injection!   
            echo "<h2>" . $user_name . "!!</h2>";
        }
    }
    ?>
</body>
</html>
```

### 💥 Exploit:

```php
<h1>Injected</h1>
```

> ✅ Passes because characters like `h`, `1`, `I`, etc., are in the allowed set.

### 🛠️ Bypass Technique:

```php
a<script>alert(1)</script>
```

**Vulnerability explanation:**

* The regular expression `/[a-z\d_\-\.]/i` will match as long as there is at least one allowed character in the input, not that the entire input is only allowed characters.
* Input like `<h1>Injected</h1>` will pass the check because letters like h, i, n, etc. are part of the allowed set.
* No output escaping is done before echoing the value in the `<h2>` tag, so HTML code in the input is rendered.
* Thus, an attacker can still inject arbitrary HTML into the output.

> ⚠️ The regex only *checks if input contains* allowed characters — it doesn’t reject bad ones **outside** the list.

---

## 🔥 2. `html-injection-white-list2.php` — Completely Vulnerable

**Below is your provided code, updated for whitespace, indentation, and readability only.
The vulnerability is preserved.
The regular expression used does NOT fully validate that the entire input contains only allowed characters, so HTML injection remains possible.**

```php
html-injection-white-list2.php
```

```php
<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Html Injection White List - 2</title>
</head>
<body>
    <h1>Html Injection White List - 2</h1>
    <form action="html-injection-white-list2.php" method="POST">
        User Name: <input type="text" name="user"><br />
        <input type="submit" value="login">
    </form>

    <?php
    if (isset($_REQUEST['user'])) {
        $user_name = $_REQUEST['user'];

        // ❌ Weak Regex: This regex only checks if the first character is allowed.
        // Any subsequent characters can be anything, so input like "<h1>Injection" will still pass.
        if (preg_match('/^[a-z\d_\.\-]/i', $user_name)) {
            echo '<h2>' . $user_name . '!</h2>'; // No sanitization
        } else {
          // No output sanitization: This is still Vulnerable to HTML Injection!
            die("Don't try to Inject Code");
        }
    }
    ?>
</body>
</html>
```

### 💥 Exploit:

```php
a<script>alert('XSS')</script>
```

* The regular expression `/^[a-z\d_\.\-]/i` only checks whether the **first character** is in the allowed list (`a-z`, `0–9`, `_`, `.`, or `-`).
* Any characters AFTER the first can be anything — including HTML tags or other injection payloads.
* Example: `A<script>alert(1)</script>` will pass the check.
* The value is printed directly inside `<h2>` without encoding or sanitization.
* An attacker can submit a payload that starts with an allowed character and inject arbitrary HTML into the page — maintaining the vulnerability as requested.

> ⚠️ Only one matching character (e.g., `a`) is enough for input to be accepted. Full injection follows.

---

## 🛡️3. `html-injection-white-list3.php` — Improved, But Still Risky

**The vulnerability is preserved.**
However, this version uses a stricter regular expression, which only allows letters, digits, dot, dash, and underscore throughout the whole input (`/^[a-z\d\.\-\_]*$/i`).
So basic HTML injection via angle brackets (`<` and `>`) is blocked,
but it is still important to note that the code does not perform output encoding or escaping.

```php
html-injection-white-list3.php
```

```php
<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Html Injection White List - 3</title>
</head>
<body>
    <h1>Html Injection White List - 3</h1>
    <form action="html-injection-white-list3.php" method="POST">
        User Name: <input type="text" name="user"><br />
        <input type="submit" value="login">
    </form>

    <?php
    if (isset($_REQUEST['user'])) {
        $user_name = $_REQUEST['user'];

        // This Regex only allows a-z, 0-9, dot, dash, and underscore, any length (including empty string)
        if (!preg_match('/^[a-z\d\.\-\_]*$/i', $user_name)) {
            die("Don't try to Inject Code");
        } else {
           // No output sanitization: Printing directly in HTML context.       
            echo "<h2>" . $user_name . "!</h2>";
        }
    }
    ?>
</body>
</html>
```

### 💥 Exploit:

```php
admin_user-12
```

**Vulnerability Analysis**

* Only these characters are accepted: `a-z`, `A-Z`, `0–9`, `.`, `_`, `-`
* No output encoding:
  The code echoes `$user_name` directly inside an HTML element.

**Potential risk:**

* Angle brackets are not allowed, so basic HTML injection using tags like `<script>` or `<img>` is blocked.
* Other forms of injection (like JavaScript event attributes or Unicode tricks) are also mostly prevented due to character restrictions.
* If the allowed character set is later expanded, or additional vectors are possible depending on browser or context, risk may still exist.

---
